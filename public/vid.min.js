var Vid = (function (exports) {
    'use strict';

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM
    // at the end of hydration without touching the remaining nodes.
    let is_hydrating = false;
    function start_hydrating() {
        is_hydrating = true;
    }
    function end_hydrating() {
        is_hydrating = false;
    }
    function upper_bound(low, high, key, value) {
        // Return first index of value larger than input value in the range [low, high)
        while (low < high) {
            const mid = low + ((high - low) >> 1);
            if (key(mid) <= value) {
                low = mid + 1;
            }
            else {
                high = mid;
            }
        }
        return low;
    }
    function init_hydrate(target) {
        if (target.hydrate_init)
            return;
        target.hydrate_init = true;
        // We know that all children have claim_order values since the unclaimed have been detached
        const children = target.childNodes;
        /*
        * Reorder claimed children optimally.
        * We can reorder claimed children optimally by finding the longest subsequence of
        * nodes that are already claimed in order and only moving the rest. The longest
        * subsequence subsequence of nodes that are claimed in order can be found by
        * computing the longest increasing subsequence of .claim_order values.
        *
        * This algorithm is optimal in generating the least amount of reorder operations
        * possible.
        *
        * Proof:
        * We know that, given a set of reordering operations, the nodes that do not move
        * always form an increasing subsequence, since they do not move among each other
        * meaning that they must be already ordered among each other. Thus, the maximal
        * set of nodes that do not move form a longest increasing subsequence.
        */
        // Compute longest increasing subsequence
        // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j
        const m = new Int32Array(children.length + 1);
        // Predecessor indices + 1
        const p = new Int32Array(children.length);
        m[0] = -1;
        let longest = 0;
        for (let i = 0; i < children.length; i++) {
            const current = children[i].claim_order;
            // Find the largest subsequence length such that it ends in a value less than our current value
            // upper_bound returns first greater value, so we subtract one
            const seqLen = upper_bound(1, longest + 1, idx => children[m[idx]].claim_order, current) - 1;
            p[i] = m[seqLen] + 1;
            const newLen = seqLen + 1;
            // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.
            m[newLen] = i;
            longest = Math.max(newLen, longest);
        }
        // The longest increasing subsequence of nodes (initially reversed)
        const lis = [];
        // The rest of the nodes, nodes that will be moved
        const toMove = [];
        let last = children.length - 1;
        for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
            lis.push(children[cur - 1]);
            for (; last >= cur; last--) {
                toMove.push(children[last]);
            }
            last--;
        }
        for (; last >= 0; last--) {
            toMove.push(children[last]);
        }
        lis.reverse();
        // We sort the nodes being moved to guarantee that their insertion order matches the claim order
        toMove.sort((a, b) => a.claim_order - b.claim_order);
        // Finally, we move the nodes
        for (let i = 0, j = 0; i < toMove.length; i++) {
            while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {
                j++;
            }
            const anchor = j < lis.length ? lis[j] : null;
            target.insertBefore(toMove[i], anchor);
        }
    }
    function append(target, node) {
        if (is_hydrating) {
            init_hydrate(target);
            if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {
                target.actual_end_child = target.firstChild;
            }
            if (node !== target.actual_end_child) {
                target.insertBefore(node, target.actual_end_child);
            }
            else {
                target.actual_end_child = node.nextSibling;
            }
        }
        else if (node.parentNode !== target) {
            target.appendChild(node);
        }
    }
    function insert(target, node, anchor) {
        if (is_hydrating && !anchor) {
            append(target, node);
        }
        else if (node.parentNode !== target || node.nextSibling != anchor) {
            target.insertBefore(node, anchor || null);
        }
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_data(text, data) {
        data = '' + data;
        if (text.wholeText !== data)
            text.data = data;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                start_hydrating();
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            end_hydrating();
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    /**
     * Generates a random UUID (version 4). This can be used as a decentralized way
     * to create an identifier that has such a low probability of collision that it
     * can essentially be treated as universally unique.
     *
     * @returns {string}
     */
    function uuidv4() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (Math.random() * 16) | 0,
          v = c == 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16)
      })
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    function createElementAndTrackStore() {
      let attachedTrack;

      const elementStore = writable(null);
      const trackStore = writable(null);

      const detach = () => {
        const element = get_store_value(elementStore);
        if (attachedTrack) {
          attachedTrack.detach(element);
          attachedTrack = null;
        }
      };

      const attach = () => {
        const track = get_store_value(trackStore);
        const element = get_store_value(elementStore);
        if (track && track !== attachedTrack) {
          detach();
          attachedTrack = track;
          track.attach(element);
        }
      };

      const store = derived([elementStore, trackStore], ([$element, $track]) => {
        return { element: $element, track: $track }
      });

      const unsubscribe = store.subscribe(($props) => {
        if ($props.element && $props.track) {
          attach();
        }
      });

      return {
        subscribe: store.subscribe,

        destroy: () => {
          detach();
          unsubscribe();
        },

        setElement: (element) => {
          elementStore.set(element);
        },

        setTrack: (track) => {
          if (track !== get_store_value(trackStore)) {
            trackStore.set(track);
          }
        },
      }
    }

    /* src/components/Audio/Audio.svelte generated by Svelte v3.39.0 */

    function create_fragment$5(ctx) {
    	let audio;
    	let audio_loop_value;
    	let audio_autoplay_value;

    	return {
    		c() {
    			audio = element("audio");
    			attr(audio, "id", /*id*/ ctx[0]);
    			audio.loop = audio_loop_value = /*loop*/ ctx[1] ? true : undefined;
    			audio.autoplay = audio_autoplay_value = /*autoPlay*/ ctx[2] ? true : undefined;
    		},
    		m(target, anchor) {
    			insert(target, audio, anchor);
    			/*audio_binding*/ ctx[5](audio);
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*id*/ 1) {
    				attr(audio, "id", /*id*/ ctx[0]);
    			}

    			if (dirty & /*loop*/ 2 && audio_loop_value !== (audio_loop_value = /*loop*/ ctx[1] ? true : undefined)) {
    				audio.loop = audio_loop_value;
    			}

    			if (dirty & /*autoPlay*/ 4 && audio_autoplay_value !== (audio_autoplay_value = /*autoPlay*/ ctx[2] ? true : undefined)) {
    				audio.autoplay = audio_autoplay_value;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(audio);
    			/*audio_binding*/ ctx[5](null);
    		}
    	};
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { id = uuidv4() } = $$props;
    	let { loop = false } = $$props;
    	let { autoPlay = true } = $$props;
    	let { track = undefined } = $$props;
    	let audioElement;
    	const store = createElementAndTrackStore();
    	onMount(() => store.setElement(audioElement));
    	afterUpdate(() => store.setTrack(track));
    	onDestroy(store.destroy);

    	function audio_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			audioElement = $$value;
    			$$invalidate(3, audioElement);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('id' in $$props) $$invalidate(0, id = $$props.id);
    		if ('loop' in $$props) $$invalidate(1, loop = $$props.loop);
    		if ('autoPlay' in $$props) $$invalidate(2, autoPlay = $$props.autoPlay);
    		if ('track' in $$props) $$invalidate(4, track = $$props.track);
    	};

    	return [id, loop, autoPlay, audioElement, track, audio_binding];
    }

    class Audio extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { id: 0, loop: 1, autoPlay: 2, track: 4 });
    	}
    }

    /* src/components/Video/Video.svelte generated by Svelte v3.39.0 */

    function create_fragment$4(ctx) {
    	let video;
    	let video_autoplay_value;
    	let video_playsinline_value;

    	return {
    		c() {
    			video = element("video");
    			attr(video, "id", /*id*/ ctx[0]);
    			video.autoplay = video_autoplay_value = /*autoPlay*/ ctx[1] ? true : undefined;
    			video.playsInline = video_playsinline_value = /*playsInline*/ ctx[3] ? true : undefined;
    			attr(video, "disablepictureinpicture", "");
    			attr(video, "class", "svelte-yvcj9o");
    			toggle_class(video, "mirror", /*mirror*/ ctx[4]);
    			toggle_class(video, "fullscreen", /*fullscreen*/ ctx[2]);
    		},
    		m(target, anchor) {
    			insert(target, video, anchor);
    			/*video_binding*/ ctx[7](video);
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*id*/ 1) {
    				attr(video, "id", /*id*/ ctx[0]);
    			}

    			if (dirty & /*autoPlay*/ 2 && video_autoplay_value !== (video_autoplay_value = /*autoPlay*/ ctx[1] ? true : undefined)) {
    				video.autoplay = video_autoplay_value;
    			}

    			if (dirty & /*playsInline*/ 8 && video_playsinline_value !== (video_playsinline_value = /*playsInline*/ ctx[3] ? true : undefined)) {
    				video.playsInline = video_playsinline_value;
    			}

    			if (dirty & /*mirror*/ 16) {
    				toggle_class(video, "mirror", /*mirror*/ ctx[4]);
    			}

    			if (dirty & /*fullscreen*/ 4) {
    				toggle_class(video, "fullscreen", /*fullscreen*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(video);
    			/*video_binding*/ ctx[7](null);
    		}
    	};
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { id = uuidv4() } = $$props;
    	let { autoPlay = true } = $$props;
    	let { fullscreen = false } = $$props;
    	let { playsInline = true } = $$props;
    	let { track = null } = $$props;
    	let { mirror = false } = $$props;
    	let videoElement;
    	const store = createElementAndTrackStore();
    	onMount(() => store.setElement(videoElement));
    	afterUpdate(() => store.setTrack(track));
    	onDestroy(store.destroy);

    	function video_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			videoElement = $$value;
    			$$invalidate(5, videoElement);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('id' in $$props) $$invalidate(0, id = $$props.id);
    		if ('autoPlay' in $$props) $$invalidate(1, autoPlay = $$props.autoPlay);
    		if ('fullscreen' in $$props) $$invalidate(2, fullscreen = $$props.fullscreen);
    		if ('playsInline' in $$props) $$invalidate(3, playsInline = $$props.playsInline);
    		if ('track' in $$props) $$invalidate(6, track = $$props.track);
    		if ('mirror' in $$props) $$invalidate(4, mirror = $$props.mirror);
    	};

    	return [
    		id,
    		autoPlay,
    		fullscreen,
    		playsInline,
    		mirror,
    		videoElement,
    		track,
    		video_binding
    	];
    }

    class Video extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
    			id: 0,
    			autoPlay: 1,
    			fullscreen: 2,
    			playsInline: 3,
    			track: 6,
    			mirror: 4
    		});
    	}
    }

    function is_date(obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    }

    function tick_spring(ctx, last_value, current_value, target_value) {
        if (typeof current_value === 'number' || is_date(current_value)) {
            // @ts-ignore
            const delta = target_value - current_value;
            // @ts-ignore
            const velocity = (current_value - last_value) / (ctx.dt || 1 / 60); // guard div by 0
            const spring = ctx.opts.stiffness * delta;
            const damper = ctx.opts.damping * velocity;
            const acceleration = (spring - damper) * ctx.inv_mass;
            const d = (velocity + acceleration) * ctx.dt;
            if (Math.abs(d) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) {
                return target_value; // settled
            }
            else {
                ctx.settled = false; // signal loop to keep ticking
                // @ts-ignore
                return is_date(current_value) ?
                    new Date(current_value.getTime() + d) : current_value + d;
            }
        }
        else if (Array.isArray(current_value)) {
            // @ts-ignore
            return current_value.map((_, i) => tick_spring(ctx, last_value[i], current_value[i], target_value[i]));
        }
        else if (typeof current_value === 'object') {
            const next_value = {};
            for (const k in current_value) {
                // @ts-ignore
                next_value[k] = tick_spring(ctx, last_value[k], current_value[k], target_value[k]);
            }
            // @ts-ignore
            return next_value;
        }
        else {
            throw new Error(`Cannot spring ${typeof current_value} values`);
        }
    }
    function spring(value, opts = {}) {
        const store = writable(value);
        const { stiffness = 0.15, damping = 0.8, precision = 0.01 } = opts;
        let last_time;
        let task;
        let current_token;
        let last_value = value;
        let target_value = value;
        let inv_mass = 1;
        let inv_mass_recovery_rate = 0;
        let cancel_task = false;
        function set(new_value, opts = {}) {
            target_value = new_value;
            const token = current_token = {};
            if (value == null || opts.hard || (spring.stiffness >= 1 && spring.damping >= 1)) {
                cancel_task = true; // cancel any running animation
                last_time = now();
                last_value = new_value;
                store.set(value = target_value);
                return Promise.resolve();
            }
            else if (opts.soft) {
                const rate = opts.soft === true ? .5 : +opts.soft;
                inv_mass_recovery_rate = 1 / (rate * 60);
                inv_mass = 0; // infinite mass, unaffected by spring forces
            }
            if (!task) {
                last_time = now();
                cancel_task = false;
                task = loop(now => {
                    if (cancel_task) {
                        cancel_task = false;
                        task = null;
                        return false;
                    }
                    inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1);
                    const ctx = {
                        inv_mass,
                        opts: spring,
                        settled: true,
                        dt: (now - last_time) * 60 / 1000
                    };
                    const next_value = tick_spring(ctx, last_value, value, target_value);
                    last_time = now;
                    last_value = value;
                    store.set(value = next_value);
                    if (ctx.settled) {
                        task = null;
                    }
                    return !ctx.settled;
                });
            }
            return new Promise(fulfil => {
                task.promise.then(() => {
                    if (token === current_token)
                        fulfil();
                });
            });
        }
        const spring = {
            set,
            update: (fn, opts) => set(fn(target_value, value), opts),
            subscribe: store.subscribe,
            stiffness,
            damping,
            precision
        };
        return spring;
    }

    async function canAutoPermit() {
      return new Promise((resolve) => {
        // If the browser allows us to enumerate any of the devices, then
        // there is at least some "permission" granted by the user from
        // the last time they visited. Take the hint and attempt to request
        // full permission to use audio & video.
        if (JitsiMeetJS.mediaDevices.isDeviceListAvailable()) {
          JitsiMeetJS.mediaDevices.enumerateDevices((deviceList) => {
            let autoPermit = false;
            for (const device of deviceList) {
              if (device.label) autoPermit = true;
            }
            resolve(autoPermit);
          });
        } else {
          resolve(false);
        }
      })
    }

    function ready(fn) {
      if (document.readyState === 'complete') {
        fn();
      } else {
        document.addEventListener('readystatechange', () => {
          if (document.readyState === 'complete') {
            fn();
          }
        });
      }
    }

    /**
     * The DeviceListStore is responsible for being an up-to-date list of media devices
     * available to the app.
     *
     * Available means:
     *   1. There is sufficient permission granted by the user (via the browser's getUserMedia call)
     *   2. The device is plugged in and listed by the browser
     */

    const { DEVICE_LIST_CHANGED } = JitsiMeetJS.events.mediaDevices;
    const { mediaDevices } = JitsiMeetJS;

    async function getDeviceList() {
      return new Promise((resolve, reject) => {
        if (JitsiMeetJS.mediaDevices.isDeviceListAvailable()) {
          JitsiMeetJS.mediaDevices.enumerateDevices((deviceList) =>
            resolve(deviceList)
          );
        } else {
          reject(new Error('Device List not available'));
        }
      })
    }

    function createDeviceListStore() {
      const { subscribe, set } = writable([]);

      // Sets the deviceList array, and augments with pseudo-devices if needed
      const setDeviceList = (deviceList_) => {
        // Clone the deviceList so we aren't modifying the original
        const deviceList = deviceList_.slice();

        // In some browsers such as Firefox, the audiooutput is not listed
        // when there is just one default device, so create a pseudo-device
        const atLeastOneAudioOutputDevice = !!deviceList.find(
          (device) => device.kind === 'audiooutput'
        );

        if (!atLeastOneAudioOutputDevice) {
          deviceList.push({
            deviceId: 'default',
            kind: 'audiooutput',
            label: 'Default Speakers',
          });
        }

        set(deviceList);
      };

      // Initialize the deviceList with whatever the browser will tell us at this time
      ready(() => {
        getDeviceList().then(setDeviceList);
      });

      // Whenever there is a device change event, update the store
      mediaDevices.addEventListener(DEVICE_LIST_CHANGED, setDeviceList);

      return {
        // DeviceList behaves as a Svelte-subscribable store
        subscribe,

        // DeviceList can be set, e.g. on callbacks and events returned by Jitsi
        set: setDeviceList,

        // Instruct DeviceList to ask the browser for its most recent enumeration of devices
        requery: async () => {
          const deviceList = await getDeviceList();
          setDeviceList(deviceList);
          return deviceList
        },
      }
    }

    // The default store containing an array of MediaDeviceInfo devices
    const deviceList = createDeviceListStore();

    // Given a deviceList, pick out the most likely default device of a certain kind
    function getDefaultDeviceId(deviceList, kind) {
      const deviceListOfKind = deviceList.filter((device) => device.kind === kind);
      const defaultDevice = deviceListOfKind.find((d) => d.deviceId === 'default');

      let matchingDevice;

      if (defaultDevice) {
        // Find the device with a matching group id.
        matchingDevice = deviceListOfKind.find(
          (d) => d.deviceId !== 'default' && d.groupId === defaultDevice.groupId
        );
      }

      if (matchingDevice) {
        return matchingDevice.deviceId
      } else if (deviceListOfKind.length >= 1) {
        return deviceListOfKind[0].deviceId
      } else {
        return null
      }
    }

    const defaultDevices = derived(deviceList, ($deviceList) => {
      return {
        videoinput: getDefaultDeviceId($deviceList, 'videoinput'),
        audioinput: getDefaultDeviceId($deviceList, 'audioinput'),
        audiooutput: getDefaultDeviceId($deviceList, 'audiooutput'),
      }
    });

    const selectedDevices = writable({});

    function omit(obj, remove) {
      var result = {};
      if (typeof remove === 'string') {
        remove = [].slice.call(arguments, 1);
      }
      for (var prop in obj) {
        if (!obj.hasOwnProperty || obj.hasOwnProperty(prop)) {
          if (remove.indexOf(prop) === -1) {
            result[prop] = obj[prop];
          }
        }
      }
      return result
    }

    const { TRACK_AUDIO_LEVEL_CHANGED } = JitsiMeetJS.events.track;

    const requestedTracks = {
      audio: writable(true),
      video: writable(true),
    };

    /**
     * Converts requestedTracks to a list of track names, e.g. ['audio', 'video']
     */
    const requestedTrackNames = derived(
      [requestedTracks.audio, requestedTracks.video],
      ([$audio, $video]) =>
        [$audio ? 'audio' : null, $video ? 'video' : null].filter((x) => x),
      []
    );

    function createAudioLevelStore() {
      const { subscribe, set } = writable(0);

      /**
       * Adds or removes an event listener function if the track is an audio track
       *
       * @param {JitsiTrack} track
       * @param {string} direction - 'add' | 'remove'
       */
      const changeAudioTrackEventListener = (track, direction) => {
        if (track.getType() === 'audio') {
          track[`${direction}EventListener`](TRACK_AUDIO_LEVEL_CHANGED, set);
        }
        return track
      };

      return {
        subscribe,
        set,
        initTrack: (track) => {
          return changeAudioTrackEventListener(track, 'add')
        },
        deinitTrack: (track) => {
          return changeAudioTrackEventListener(track, 'remove')
        },
      }
    }

    const localAudioLevel = createAudioLevelStore();

    async function createLocalTracks(requestedTrackNames, selectedDevices = {}) {
      let tracks = {};

      const options = { devices: requestedTrackNames };

      // If we have a specific video camera to request, include it in the options
      if (requestedTrackNames.includes('video') && selectedDevices.videoinput) {
        options.cameraDeviceId = selectedDevices.videoinput;
      }

      // If we have a specific microphone to request, include it in the options
      if (requestedTrackNames.includes('audio') && selectedDevices.audioinput) {
        options.micDeviceId = selectedDevices.audioinput;
      }

      try {
        // Get all requested tracks at once
        for (const track of await JitsiMeetJS.createLocalTracks(options)) {
          tracks[track.getType()] = localAudioLevel.initTrack(track);
        }
      } catch (err) {
        if (requestedTrackNames.length > 1) {
          // If multiple tracks were requested, try again by requesting one at a time
          for (const requestedTrack of requestedTrackNames) {
            try {
              Object.assign(
                tracks,
                await createLocalTracks([requestedTrack], selectedDevices)
              );
            } catch (err2) {
              console.error(`Shouldn't happen:`, err2);
            }
          }
        } else {
          console.warn(
            `Unable to create local track: ${requestedTrackNames.join(', ')}`
          );
        }
      }

      return tracks
    }

    function createLocalTracksStore() {
      const store = writable({});
      const { subscribe, update, set } = store;

      function clear() {
        const tracks = get_store_value(store);

        // Clean up from past local track creation
        for (const track of Object.values(tracks)) {
          localAudioLevel.deinitTrack(track);
        }

        // Reset localTracks to empty object
        set({});
      }

      return {
        // LocalTracksStore behaves as a Svelte-subscribable store
        subscribe,

        // LocalTracksStore can be set
        set,

        count: () => {
          return Object.values(get_store_value()).length
        },

        /**
         * Switch from sharing video to sharing desktop, or back if `desktop` is false.
         */
        shareDesktop: async (desktop = true) => {
          const desktopTracks = await createLocalTracks([
            desktop ? 'desktop' : 'video',
          ]);

          update(($tracks) => {
            if ($tracks.video) {
              $tracks.video.dispose();
            }
            return omit($tracks, ['video'])
          });

          setTimeout(() => {
            update(($tracks) => {
              return { ...$tracks, ...desktopTracks }
            });
          }, 1000);
        },

        /**
         * Create multiple local tracks at once, or if error, create multiple
         * local tracks one at a time. Takes into account `selectedDevices`
         * setting that is "global" to this component.
         *
         * @param {[string]} requestedTracks - a list of types of devices to allocate as tracks, e.g. ['video', 'audio']
         *
         * @returns {Object} - an object with keys equal to device types and values set to corresponding JitsiTrack
         */
        request: async ({ requestedTracks, selectedDevices: selectedDevices$1 } = {}) => {
          if (!requestedTracks) {
            requestedTracks = get_store_value(requestedTrackNames);
          }

          if (!selectedDevices$1) {
            selectedDevices$1 = get_store_value(selectedDevices);
          }

          const tracks = await createLocalTracks(requestedTracks, selectedDevices$1);

          clear();

          set(tracks);

          return Object.values(tracks).length > 0
        },

        // De-initialize existing tracks & clear the LocalTracksStore
        clear,
      }
    }

    const localTracksStore = createLocalTracksStore();

    /* src/components/Mirror/ContinueButton/ContinueButton.svelte generated by Svelte v3.39.0 */

    function fallback_block(ctx) {
    	let t;

    	return {
    		c() {
    			t = text("Join");
    		},
    		m(target, anchor) {
    			insert(target, t, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(t);
    		}
    	};
    }

    function create_fragment$3(ctx) {
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);
    	const default_slot_or_fallback = default_slot || fallback_block();

    	return {
    		c() {
    			button = element("button");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr(button, "class", "continue svelte-qmhyto");
    			toggle_class(button, "disabled", !/*enabled*/ ctx[0]);
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[4]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], !current ? -1 : dirty, null, null);
    				}
    			}

    			if (dirty & /*enabled*/ 1) {
    				toggle_class(button, "disabled", !/*enabled*/ ctx[0]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(button);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	let { enabled = true } = $$props;
    	let dispatch = createEventDispatcher();

    	const click_handler = () => {
    		dispatch('click');
    	};

    	$$self.$$set = $$props => {
    		if ('enabled' in $$props) $$invalidate(0, enabled = $$props.enabled);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	return [enabled, dispatch, $$scope, slots, click_handler];
    }

    class ContinueButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { enabled: 0 });
    	}
    }

    function groupBy(xs, key) {
      return xs.reduce((rv, x) => {
    (rv[x[key]] = rv[x[key]] || []).push(x);
        return rv
      }, {})
    }

    function hasAncestor(element, ancestor) {
      if (element === null) {
        return false
      } else if (element === ancestor) {
        return true
      } else {
        return hasAncestor(element.parentNode, ancestor)
      }
    }

    /* src/components/Mirror/DeviceSelector/Select/Select.svelte generated by Svelte v3.39.0 */

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	child_ctx[19] = i;
    	return child_ctx;
    }

    // (86:4) {#if icon}
    function create_if_block_1$1(ctx) {
    	let div;
    	let img;
    	let img_src_value;

    	return {
    		c() {
    			div = element("div");
    			img = element("img");
    			if (img.src !== (img_src_value = /*icon*/ ctx[0])) attr(img, "src", img_src_value);
    			attr(img, "width", "24");
    			attr(img, "alt", "Icon");
    			attr(div, "class", "icon svelte-pjneec");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, img);
    		},
    		p(ctx, dirty) {
    			if (dirty & /*icon*/ 1 && img.src !== (img_src_value = /*icon*/ ctx[0])) {
    				attr(img, "src", img_src_value);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (92:2) {#if popupVisible}
    function create_if_block$1(ctx) {
    	let div;
    	let mounted;
    	let dispose;
    	let each_value = /*optionsWithDefault*/ ctx[1];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	return {
    		c() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr(div, "class", "popup svelte-pjneec");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			if (!mounted) {
    				dispose = listen(div, "mouseleave", /*mouseleave_handler*/ ctx[16]);
    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty & /*optionsWithDefault, hoverIndex, makeSelection*/ 274) {
    				each_value = /*optionsWithDefault*/ ctx[1];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (94:6) {#each optionsWithDefault as option, i}
    function create_each_block$1(ctx) {
    	let div;
    	let t0_value = /*option*/ ctx[17].label + "";
    	let t0;
    	let t1;
    	let div_data_value_value;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[14](/*option*/ ctx[17]);
    	}

    	function mouseenter_handler() {
    		return /*mouseenter_handler*/ ctx[15](/*i*/ ctx[19]);
    	}

    	return {
    		c() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			attr(div, "class", "option svelte-pjneec");
    			attr(div, "data-value", div_data_value_value = /*option*/ ctx[17].value);
    			toggle_class(div, "hover", /*hoverIndex*/ ctx[4] === /*i*/ ctx[19]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, t0);
    			append(div, t1);

    			if (!mounted) {
    				dispose = [
    					listen(div, "click", click_handler),
    					listen(div, "mouseenter", mouseenter_handler)
    				];

    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*optionsWithDefault*/ 2 && t0_value !== (t0_value = /*option*/ ctx[17].label + "")) set_data(t0, t0_value);

    			if (dirty & /*optionsWithDefault*/ 2 && div_data_value_value !== (div_data_value_value = /*option*/ ctx[17].value)) {
    				attr(div, "data-value", div_data_value_value);
    			}

    			if (dirty & /*hoverIndex*/ 16) {
    				toggle_class(div, "hover", /*hoverIndex*/ ctx[4] === /*i*/ ctx[19]);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function create_fragment$2(ctx) {
    	let div3;
    	let div2;
    	let t0;
    	let div0;

    	let t1_value = (/*selectedOption*/ ctx[5]
    	? /*selectedOption*/ ctx[5].label
    	: "") + "";

    	let t1;
    	let t2;
    	let div1;
    	let t3;
    	let mounted;
    	let dispose;
    	let if_block0 = /*icon*/ ctx[0] && create_if_block_1$1(ctx);
    	let if_block1 = /*popupVisible*/ ctx[3] && create_if_block$1(ctx);

    	return {
    		c() {
    			div3 = element("div");
    			div2 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div0 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			div1 = element("div");
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr(div0, "class", "selected svelte-pjneec");
    			attr(div1, "class", "down-arrow svelte-pjneec");
    			attr(div2, "class", "select-row svelte-pjneec");
    			toggle_class(div2, "open", /*popupVisible*/ ctx[3]);
    			attr(div3, "class", "select svelte-pjneec");
    			attr(div3, "tabindex", "0");
    		},
    		m(target, anchor) {
    			insert(target, div3, anchor);
    			append(div3, div2);
    			if (if_block0) if_block0.m(div2, null);
    			append(div2, t0);
    			append(div2, div0);
    			append(div0, t1);
    			append(div2, t2);
    			append(div2, div1);
    			/*div2_binding*/ ctx[13](div2);
    			append(div3, t3);
    			if (if_block1) if_block1.m(div3, null);

    			if (!mounted) {
    				dispose = [
    					listen(div2, "click", /*togglePopup*/ ctx[6]),
    					listen(div3, "keydown", /*handleKeypress*/ ctx[9]),
    					listen(div3, "blur", /*cancelPopup*/ ctx[7])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (/*icon*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$1(ctx);
    					if_block0.c();
    					if_block0.m(div2, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*selectedOption*/ 32 && t1_value !== (t1_value = (/*selectedOption*/ ctx[5]
    			? /*selectedOption*/ ctx[5].label
    			: "") + "")) set_data(t1, t1_value);

    			if (dirty & /*popupVisible*/ 8) {
    				toggle_class(div2, "open", /*popupVisible*/ ctx[3]);
    			}

    			if (/*popupVisible*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$1(ctx);
    					if_block1.c();
    					if_block1.m(div3, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div3);
    			if (if_block0) if_block0.d();
    			/*div2_binding*/ ctx[13](null);
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    const KEY_RETURN = 13;
    const KEY_SPACE = 32;
    const KEY_UP = 38;
    const KEY_DOWN = 40;
    const KEY_ESCAPE = 27;

    function instance$2($$self, $$props, $$invalidate) {
    	let { selected = null } = $$props;
    	let { options = null } = $$props;
    	let { icon = null } = $$props;
    	let { onSelect = null } = $$props;
    	let selectRowEl = null;
    	let popupVisible = false;
    	let hoverIndex = null;
    	let selectedOption;
    	let optionsWithDefault;
    	const togglePopup = () => $$invalidate(3, popupVisible = !popupVisible);

    	const cancelPopup = event => {
    		if (!hasAncestor(event.target, selectRowEl)) {
    			$$invalidate(3, popupVisible = false);
    		}
    	};

    	const makeSelection = option => {
    		$$invalidate(10, selected = option.value);

    		if (onSelect) {
    			onSelect(option);
    		}
    	};

    	const handleKeypress = event => {
    		const options = optionsWithDefault;

    		if (event.keyCode === KEY_ESCAPE && popupVisible) {
    			$$invalidate(4, hoverIndex = null);
    			togglePopup();
    		} else if (event.keyCode === KEY_RETURN || event.keyCode === KEY_SPACE) {
    			if (hoverIndex !== null && hoverIndex >= 0 && hoverIndex < options.length) {
    				const option = options[hoverIndex];
    				makeSelection(option);
    			} else {
    				$$invalidate(4, hoverIndex = options.findIndex(opt => opt.value === selected));
    			}

    			togglePopup();
    		} else if (event.keyCode === KEY_UP) {
    			if ($$invalidate(4, --hoverIndex) < 0) $$invalidate(4, hoverIndex = 0);
    		} else if (event.keyCode === KEY_DOWN) {
    			if ($$invalidate(4, ++hoverIndex) >= options.length) $$invalidate(4, hoverIndex = options.length - 1);
    		}
    	};

    	onMount(() => {
    		document.addEventListener("click", cancelPopup);

    		return () => {
    			document.removeEventListener("click", cancelPopup);
    		};
    	});

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			selectRowEl = $$value;
    			$$invalidate(2, selectRowEl);
    		});
    	}

    	const click_handler = option => makeSelection(option);
    	const mouseenter_handler = i => $$invalidate(4, hoverIndex = i);
    	const mouseleave_handler = () => $$invalidate(4, hoverIndex = null);

    	$$self.$$set = $$props => {
    		if ('selected' in $$props) $$invalidate(10, selected = $$props.selected);
    		if ('options' in $$props) $$invalidate(11, options = $$props.options);
    		if ('icon' in $$props) $$invalidate(0, icon = $$props.icon);
    		if ('onSelect' in $$props) $$invalidate(12, onSelect = $$props.onSelect);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*options*/ 2048) {
    			$$invalidate(1, optionsWithDefault = options || []);
    		}

    		if ($$self.$$.dirty & /*optionsWithDefault, selected*/ 1026) {
    			$$invalidate(5, selectedOption = optionsWithDefault.find(opt => opt.value === selected));
    		}
    	};

    	return [
    		icon,
    		optionsWithDefault,
    		selectRowEl,
    		popupVisible,
    		hoverIndex,
    		selectedOption,
    		togglePopup,
    		cancelPopup,
    		makeSelection,
    		handleKeypress,
    		selected,
    		options,
    		onSelect,
    		div2_binding,
    		click_handler,
    		mouseenter_handler,
    		mouseleave_handler
    	];
    }

    class Select extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
    			selected: 10,
    			options: 11,
    			icon: 0,
    			onSelect: 12
    		});
    	}
    }

    var img$7 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3c!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg width='100%25' height='100%25' viewBox='0 0 446 446' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' xml:space='preserve' xmlns:serif='http://www.serif.com/' style='fill-rule:evenodd%3bclip-rule:evenodd%3bstroke-linejoin:round%3bstroke-miterlimit:2%3b'%3e %3cg transform='matrix(1%2c0%2c0%2c1%2c-1680.29%2c-1007.26)'%3e %3cg%3e %3cg transform='matrix(1.02212%2c0%2c0%2c1.02212%2c206.889%2c-81.1536)'%3e %3crect x='1441.53' y='1064.86' width='435.694' height='435.694' style='fill:none%3b'/%3e %3c/g%3e %3cpath d='M1880.04%2c1375.04C1756.22%2c1360.69 1753.26%2c1230.45 1753.26%2c1230.45L1799.09%2c1229.4C1799.09%2c1229.4 1801.44%2c1330.49 1902.96%2c1330.49C2004.48%2c1330.49 2006.83%2c1229.4 2006.83%2c1229.4L2052.65%2c1230.45C2052.65%2c1230.45 2049.7%2c1360.69 1925.88%2c1375.04L1925.88%2c1410.24L1880.04%2c1410.24L1880.04%2c1375.04Z' style='fill:rgb(239%2c239%2c239)%3b'/%3e %3cg transform='matrix(1%2c0%2c0%2c0.538482%2c493.195%2c640.079)'%3e %3cpath d='M1488.93%2c1095.38L1488.93%2c927.954C1488.93%2c846.812 1453.46%2c780.935 1409.76%2c780.935C1366.07%2c780.935 1330.6%2c846.812 1330.6%2c927.954L1330.6%2c1095.38C1330.6%2c1176.52 1366.07%2c1242.4 1409.76%2c1242.4C1453.46%2c1242.4 1488.93%2c1176.52 1488.93%2c1095.38Z' style='fill:rgb(239%2c239%2c239)%3b'/%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

    var img$6 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3c!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg width='100%25' height='100%25' viewBox='0 0 446 446' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' xml:space='preserve' xmlns:serif='http://www.serif.com/' style='fill-rule:evenodd%3bclip-rule:evenodd%3bstroke-linejoin:round%3bstroke-miterlimit:2%3b'%3e %3cg transform='matrix(1%2c0%2c0%2c1%2c-1780.85%2c-1060.26)'%3e %3cg%3e %3cg transform='matrix(1.02212%2c0%2c0%2c1.02212%2c307.449%2c-28.1508)'%3e %3crect x='1441.53' y='1064.86' width='435.694' height='435.694' style='fill:none%3b'/%3e %3c/g%3e %3cpath d='M2107.48%2c1193.89C2107.48%2c1171.02 2088.91%2c1152.45 2066.04%2c1152.45L1893.58%2c1152.45C1870.71%2c1152.45 1852.14%2c1171.02 1852.14%2c1193.89L1852.14%2c1366.37C1852.14%2c1389.24 1870.71%2c1407.81 1893.58%2c1407.81L2066.04%2c1407.81C2088.91%2c1407.81 2107.48%2c1389.24 2107.48%2c1366.37L2107.48%2c1193.89ZM2107.65%2c1333.32L2107.48%2c1226.76L2174.3%2c1202.37C2174.3%2c1202.37 2181.73%2c1198.32 2187.32%2c1203.11C2192.92%2c1207.9 2192.41%2c1213.54 2192.41%2c1213.54L2192.41%2c1346.81C2192.41%2c1346.81 2193.41%2c1353.79 2186.76%2c1357.84C2180.12%2c1361.9 2174.79%2c1358.63 2174.79%2c1358.63L2107.65%2c1333.32Z' style='fill:rgb(239%2c239%2c239)%3b'/%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

    var img$5 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3csvg xmlns='http://www.w3.org/2000/svg' version='1.0' width='500' height='500' viewBox='0 0 75 75'%3e%3cpath d='M39.389%2c13.769 L22.235%2c28.606 L6%2c28.606 L6%2c47.699 L21.989%2c47.699 L39.389%2c62.75 L39.389%2c13.769z' style='stroke:%23111%3bstroke-width:5%3bstroke-linejoin:round%3bfill:%23111%3b'/%3e%3cpath d='M48%2c27.6a19.5%2c19.5 0 0 1 0%2c21.4M55.1%2c20.5a30%2c30 0 0 1 0%2c35.6M61.6%2c14a38.8%2c38.8 0 0 1 0%2c48.6' style='fill:none%3bstroke:%23111%3bstroke-width:5%3bstroke-linecap:round'/%3e%3c/svg%3e";

    /* src/components/Mirror/DeviceSelector/DeviceSelector.svelte generated by Svelte v3.39.0 */

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (56:0) {#each kinds as kind}
    function create_each_block(ctx) {
    	let select;
    	let current;

    	function func(...args) {
    		return /*func*/ ctx[7](/*kind*/ ctx[9], ...args);
    	}

    	select = new Select({
    			props: {
    				selected: /*$selectedDevices*/ ctx[1][/*kind*/ ctx[9]] || /*$defaultDevices*/ ctx[2][/*kind*/ ctx[9]],
    				options: /*options*/ ctx[0][/*kind*/ ctx[9]],
    				onSelect: func,
    				icon: /*icons*/ ctx[4][/*kind*/ ctx[9]]
    			}
    		});

    	return {
    		c() {
    			create_component(select.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(select, target, anchor);
    			current = true;
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			const select_changes = {};
    			if (dirty & /*$selectedDevices, $defaultDevices*/ 6) select_changes.selected = /*$selectedDevices*/ ctx[1][/*kind*/ ctx[9]] || /*$defaultDevices*/ ctx[2][/*kind*/ ctx[9]];
    			if (dirty & /*options*/ 1) select_changes.options = /*options*/ ctx[0][/*kind*/ ctx[9]];
    			select.$set(select_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(select.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(select.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(select, detaching);
    		}
    	};
    }

    function create_fragment$1(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*kinds*/ ctx[3];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*$selectedDevices, kinds, $defaultDevices, options, selected, icons*/ 63) {
    				each_value = /*kinds*/ ctx[3];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach(each_1_anchor);
    		}
    	};
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $deviceList;
    	let $selectedDevices;
    	let $defaultDevices;
    	component_subscribe($$self, deviceList, $$value => $$invalidate(6, $deviceList = $$value));
    	component_subscribe($$self, selectedDevices, $$value => $$invalidate(1, $selectedDevices = $$value));
    	component_subscribe($$self, defaultDevices, $$value => $$invalidate(2, $defaultDevices = $$value));
    	const dispatch = createEventDispatcher();
    	const kinds = ['videoinput', 'audioinput', 'audiooutput'];

    	const icons = {
    		videoinput: img$6,
    		audioinput: img$7,
    		audiooutput: img$5
    	};

    	function selected(option, kind) {
    		if (option.value !== $selectedDevices[kind]) {
    			set_store_value(selectedDevices, $selectedDevices[kind] = option.value, $selectedDevices);
    			dispatch('changed', { kind, value: option.value });
    		}

    		dispatch('selected', { kind, value: option.value });
    	}

    	/**
     * Options are derived from deviceList: i.e. an object grouped by the kind of device:
     * {
     *   videoinput: [{ ... }, ...],
     *   audioinput: [{ ... }, ...],
     *   audiooutput: [{ ... }, ...],
     * }
     */
    	let options = {};

    	const func = (kind, option) => {
    		selected(option, kind);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$deviceList*/ 64) {
    			$$invalidate(0, options = groupBy(
    				$deviceList.map(input => ({
    					value: input.deviceId,
    					label: input.label,
    					kind: input.kind
    				})),
    				'kind'
    			));
    		}
    	};

    	return [
    		options,
    		$selectedDevices,
    		$defaultDevices,
    		kinds,
    		icons,
    		selected,
    		$deviceList,
    		func
    	];
    }

    class DeviceSelector extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});
    	}
    }

    var img$4 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3c!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg width='100%25' height='100%25' viewBox='0 0 446 446' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' xml:space='preserve' xmlns:serif='http://www.serif.com/' style='fill-rule:evenodd%3bclip-rule:evenodd%3bstroke-linejoin:round%3bstroke-miterlimit:2%3b'%3e %3cg transform='matrix(1%2c0%2c0%2c1%2c-1780.85%2c-1060.26)'%3e %3cg%3e %3cg transform='matrix(1.02212%2c0%2c0%2c1.02212%2c307.449%2c-28.1508)'%3e %3crect x='1441.53' y='1064.86' width='435.694' height='435.694' style='fill:none%3b'/%3e %3c/g%3e %3cpath d='M2107.48%2c1193.89C2107.48%2c1171.02 2088.91%2c1152.45 2066.04%2c1152.45L1893.58%2c1152.45C1870.71%2c1152.45 1852.14%2c1171.02 1852.14%2c1193.89L1852.14%2c1366.37C1852.14%2c1389.24 1870.71%2c1407.81 1893.58%2c1407.81L2066.04%2c1407.81C2088.91%2c1407.81 2107.48%2c1389.24 2107.48%2c1366.37L2107.48%2c1193.89ZM2107.65%2c1333.32L2107.48%2c1226.76L2174.3%2c1202.37C2174.3%2c1202.37 2181.73%2c1198.32 2187.32%2c1203.11C2192.92%2c1207.9 2192.41%2c1213.54 2192.41%2c1213.54L2192.41%2c1346.81C2192.41%2c1346.81 2193.41%2c1353.79 2186.76%2c1357.84C2180.12%2c1361.9 2174.79%2c1358.63 2174.79%2c1358.63L2107.65%2c1333.32Z' style='fill:rgb(239%2c239%2c239)%3b'/%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

    var img$3 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3c!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg width='100%25' height='100%25' viewBox='0 0 446 446' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' xml:space='preserve' xmlns:serif='http://www.serif.com/' style='fill-rule:evenodd%3bclip-rule:evenodd%3bstroke-linejoin:round%3bstroke-miterlimit:2%3b'%3e %3cg transform='matrix(1%2c0%2c0%2c1%2c-1430.44%2c-1053.77)'%3e %3cpath d='M1501.9%2c1332.53L1501.9%2c1187.09C1501.9%2c1187.09 1500.37%2c1172.64 1512.55%2c1159.63C1527.35%2c1143.84 1541.12%2c1145.21 1541.12%2c1145.21L1690.94%2c1145.21L1501.9%2c1332.53Z' style='fill:rgb(239%2c239%2c239)%3b'/%3e %3cpath d='M1846.25%2c1053.77L1875.88%2c1083.4L1757.17%2c1202.11L1757.17%2c1220.28L1824%2c1195.88C1824%2c1195.88 1831.42%2c1191.83 1837.02%2c1196.62C1842.61%2c1201.42 1842.11%2c1207.05 1842.11%2c1207.05L1842.11%2c1340.32C1842.11%2c1340.32 1843.11%2c1347.3 1836.46%2c1351.36C1829.81%2c1355.41 1824.49%2c1352.14 1824.49%2c1352.14L1757.35%2c1326.83L1757.35%2c1360.66C1757.35%2c1360.66 1759.16%2c1374.75 1746.61%2c1388.28C1734.06%2c1401.81 1720.07%2c1402.34 1720.07%2c1402.34L1558.06%2c1402.34L1461.3%2c1499.1L1430.44%2c1468.25L1846.25%2c1053.77Z' style='fill:rgb(239%2c239%2c239)%3b'/%3e %3c/g%3e%3c/svg%3e";

    var img$2 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3c!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg width='100%25' height='100%25' viewBox='0 0 446 446' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' xml:space='preserve' xmlns:serif='http://www.serif.com/' style='fill-rule:evenodd%3bclip-rule:evenodd%3bstroke-linejoin:round%3bstroke-miterlimit:2%3b'%3e %3cg transform='matrix(1%2c0%2c0%2c1%2c-1680.29%2c-1007.26)'%3e %3cg%3e %3cg transform='matrix(1.02212%2c0%2c0%2c1.02212%2c206.889%2c-81.1536)'%3e %3crect x='1441.53' y='1064.86' width='435.694' height='435.694' style='fill:none%3b'/%3e %3c/g%3e %3cpath d='M1880.04%2c1375.04C1756.22%2c1360.69 1753.26%2c1230.45 1753.26%2c1230.45L1799.09%2c1229.4C1799.09%2c1229.4 1801.44%2c1330.49 1902.96%2c1330.49C2004.48%2c1330.49 2006.83%2c1229.4 2006.83%2c1229.4L2052.65%2c1230.45C2052.65%2c1230.45 2049.7%2c1360.69 1925.88%2c1375.04L1925.88%2c1410.24L1880.04%2c1410.24L1880.04%2c1375.04Z' style='fill:rgb(239%2c239%2c239)%3b'/%3e %3cg transform='matrix(1%2c0%2c0%2c0.538482%2c493.195%2c640.079)'%3e %3cpath d='M1488.93%2c1095.38L1488.93%2c927.954C1488.93%2c846.812 1453.46%2c780.935 1409.76%2c780.935C1366.07%2c780.935 1330.6%2c846.812 1330.6%2c927.954L1330.6%2c1095.38C1330.6%2c1176.52 1366.07%2c1242.4 1409.76%2c1242.4C1453.46%2c1242.4 1488.93%2c1176.52 1488.93%2c1095.38Z' style='fill:rgb(239%2c239%2c239)%3b'/%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

    var img$1 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3c!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg width='100%25' height='100%25' viewBox='0 0 446 446' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' xml:space='preserve' xmlns:serif='http://www.serif.com/' style='fill-rule:evenodd%3bclip-rule:evenodd%3bstroke-linejoin:round%3bstroke-miterlimit:2%3b'%3e %3cg transform='matrix(1%2c0%2c0%2c1%2c-1174.48%2c-1007.26)'%3e %3cg transform='matrix(1%2c0%2c0%2c1%2c-505.813%2c0)'%3e %3cg transform='matrix(1.02212%2c0%2c0%2c1.02212%2c206.889%2c-81.1536)'%3e %3crect x='1441.53' y='1064.86' width='435.694' height='435.694' style='fill:none%3b'/%3e %3c/g%3e %3cg transform='matrix(1%2c0%2c0%2c1%2c505.813%2c0)'%3e %3cpath d='M1307.33%2c1350.32L1205.33%2c1452.59L1174.48%2c1421.74L1590.29%2c1007.26L1619.91%2c1036.89L1476.31%2c1180.88L1476.31%2c1229.92C1476.31%2c1273.62 1440.84%2c1309.09 1397.15%2c1309.09C1383.11%2c1309.09 1369.93%2c1305.43 1358.49%2c1299.01L1341.02%2c1316.53C1355.15%2c1324.98 1373.44%2c1330.49 1397.15%2c1330.49C1498.66%2c1330.49 1501.02%2c1229.4 1501.02%2c1229.4L1546.84%2c1230.45C1546.84%2c1230.45 1543.89%2c1360.69 1420.06%2c1375.04L1420.06%2c1410.24L1374.23%2c1410.24L1374.23%2c1375.04C1346.18%2c1371.79 1324.34%2c1362.6 1307.33%2c1350.32ZM1257.47%2c1280.33C1247.96%2c1252.98 1247.45%2c1230.45 1247.45%2c1230.45L1293.27%2c1229.4C1293.27%2c1229.4 1293.4%2c1234.79 1294.84%2c1243.08L1257.47%2c1280.33ZM1317.98%2c1220.02L1317.98%2c1139.77C1317.98%2c1096.07 1353.45%2c1060.6 1397.15%2c1060.6C1419.38%2c1060.6 1439.48%2c1069.78 1453.87%2c1084.56L1317.98%2c1220.02Z' style='fill:rgb(239%2c239%2c239)%3b'/%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

    var img = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3c!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg width='100%25' height='100%25' viewBox='0 0 446 446' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' xml:space='preserve' xmlns:serif='http://www.serif.com/' style='fill-rule:evenodd%3bclip-rule:evenodd%3bstroke-linejoin:round%3bstroke-miterlimit:2%3b'%3e %3cg transform='matrix(1%2c0%2c0%2c1%2c-1680.29%2c-1606.52)'%3e %3cg transform='matrix(1%2c0%2c0%2c1%2c-42.996%2c-59.9047)'%3e %3cg transform='matrix(1.09147%2c0%2c0%2c1.09147%2c382.662%2c-193.399)'%3e %3cpath d='M1455.8%2c1732.15C1440.19%2c1730.06 1424.37%2c1730.06 1408.75%2c1732.15C1400.38%2c1747.18 1393.43%2c1762.85 1387.92%2c1779.15C1382.68%2c1780.96 1377.55%2c1783.08 1372.57%2c1785.51C1357.14%2c1777.88 1341.15%2c1771.72 1324.6%2c1767.01C1312.08%2c1776.57 1300.89%2c1787.76 1291.33%2c1800.28C1296.04%2c1816.83 1302.21%2c1832.82 1309.84%2c1848.24C1307.4%2c1853.23 1305.28%2c1858.36 1303.48%2c1863.6C1287.17%2c1869.11 1271.51%2c1876.06 1256.47%2c1884.43C1254.38%2c1900.05 1254.38%2c1915.87 1256.47%2c1931.48C1271.51%2c1939.85 1287.17%2c1946.8 1303.48%2c1952.31C1305.28%2c1957.56 1307.4%2c1962.68 1309.84%2c1967.67C1302.21%2c1983.09 1296.04%2c1999.08 1291.33%2c2015.63C1300.89%2c2028.15 1312.08%2c2039.34 1324.6%2c2048.9C1341.15%2c2044.19 1357.14%2c2038.03 1372.57%2c2030.4C1377.55%2c2032.83 1382.68%2c2034.95 1387.92%2c2036.76C1393.43%2c2053.06 1400.38%2c2068.72 1408.75%2c2083.76C1424.37%2c2085.85 1440.19%2c2085.85 1455.8%2c2083.76C1464.17%2c2068.72 1471.12%2c2053.06 1476.63%2c2036.76C1481.88%2c2034.95 1487%2c2032.83 1491.99%2c2030.4C1507.41%2c2038.03 1523.4%2c2044.19 1539.95%2c2048.9C1552.47%2c2039.34 1563.66%2c2028.15 1573.22%2c2015.63C1568.51%2c1999.08 1562.35%2c1983.09 1554.72%2c1967.67C1557.15%2c1962.68 1559.27%2c1957.56 1561.08%2c1952.31C1577.38%2c1946.8 1593.05%2c1939.85 1608.08%2c1931.48C1610.17%2c1915.87 1610.17%2c1900.05 1608.08%2c1884.43C1593.05%2c1876.06 1577.38%2c1869.11 1561.08%2c1863.6C1559.27%2c1858.36 1557.15%2c1853.23 1554.72%2c1848.24C1562.35%2c1832.82 1568.51%2c1816.83 1573.22%2c1800.28C1563.66%2c1787.76 1552.47%2c1776.57 1539.95%2c1767.01C1523.4%2c1771.72 1507.41%2c1777.88 1491.99%2c1785.51C1487%2c1783.08 1481.88%2c1780.96 1476.63%2c1779.15C1471.12%2c1762.85 1464.17%2c1747.18 1455.8%2c1732.15ZM1432.28%2c1847.03C1465.9%2c1847.03 1493.2%2c1874.33 1493.2%2c1907.95C1493.2%2c1941.58 1465.9%2c1968.88 1432.28%2c1968.88C1398.65%2c1968.88 1371.35%2c1941.58 1371.35%2c1907.95C1371.35%2c1874.33 1398.65%2c1847.03 1432.28%2c1847.03Z' style='fill:rgb(239%2c239%2c239)%3b'/%3e %3c/g%3e %3cg transform='matrix(1.02212%2c0%2c0%2c1.02212%2c249.885%2c578.011)'%3e %3crect x='1441.53' y='1064.86' width='435.694' height='435.694' style='fill:none%3b'/%3e %3c/g%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

    /* src/components/Mirror/Mirror.svelte generated by Svelte v3.39.0 */

    function create_else_block_3(ctx) {
    	let div2;
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div1;
    	let t1;
    	let p;
    	let t3;
    	let continuebutton;
    	let current;

    	function select_block_type_4(ctx, dirty) {
    		if (/*requestBlocked*/ ctx[0]) return create_if_block_10;
    		return create_else_block_5;
    	}

    	let current_block_type = select_block_type_4(ctx);
    	let if_block = current_block_type(ctx);

    	continuebutton = new ContinueButton({
    			props: {
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			}
    		});

    	continuebutton.$on("click", /*requestPermissions*/ ctx[16]);

    	return {
    		c() {
    			div2 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			if_block.c();
    			t1 = space();
    			p = element("p");
    			p.textContent = "For others to see and hear you, your browser will request access to your\n      cam and mic.";
    			t3 = space();
    			create_component(continuebutton.$$.fragment);
    			if (img.src !== (img_src_value = img$3)) attr(img, "src", img_src_value);
    			attr(img, "width", "75");
    			attr(img, "alt", "Video Disabled");
    			attr(div0, "class", "image svelte-1puomlw");
    			attr(div1, "class", "message svelte-1puomlw");
    			attr(div2, "class", "video-stack filled svelte-1puomlw");
    			set_style(div2, "transform", "translate(" + /*$videoPositionSpring*/ ctx[7] + "px, 0)");
    			toggle_class(div2, "blocked", /*requestBlocked*/ ctx[0]);
    			attr(p, "class", "svelte-1puomlw");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);
    			append(div0, img);
    			append(div2, t0);
    			append(div2, div1);
    			if_block.m(div1, null);
    			insert(target, t1, anchor);
    			insert(target, p, anchor);
    			insert(target, t3, anchor);
    			mount_component(continuebutton, target, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_4(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			}

    			if (!current || dirty & /*$videoPositionSpring*/ 128) {
    				set_style(div2, "transform", "translate(" + /*$videoPositionSpring*/ ctx[7] + "px, 0)");
    			}

    			if (dirty & /*requestBlocked*/ 1) {
    				toggle_class(div2, "blocked", /*requestBlocked*/ ctx[0]);
    			}

    			const continuebutton_changes = {};

    			if (dirty & /*$$scope, requestBlocked*/ 16777217) {
    				continuebutton_changes.$$scope = { dirty, ctx };
    			}

    			continuebutton.$set(continuebutton_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(continuebutton.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(continuebutton.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div2);
    			if_block.d();
    			if (detaching) detach(t1);
    			if (detaching) detach(p);
    			if (detaching) detach(t3);
    			destroy_component(continuebutton, detaching);
    		}
    	};
    }

    // (109:2) {#if hasPermission}
    function create_if_block(ctx) {
    	let div2;
    	let t0;
    	let video;
    	let t1;
    	let div1;
    	let t2;
    	let div0;
    	let button0;
    	let t3;
    	let button1;
    	let t4;
    	let t5;
    	let continuebutton;
    	let t6;
    	let if_block5_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = letMeHearMyself ;

    	video = new Video({
    			props: {
    				track: /*$localTracksStore*/ ctx[5].video,
    				mirror: true
    			}
    		});

    	function select_block_type_1(ctx, dirty) {
    		if (!/*$audioRequested*/ ctx[4] && !/*$videoRequested*/ ctx[3]) return create_if_block_5;
    		if (!/*$videoRequested*/ ctx[3]) return create_if_block_6;
    		if (!/*$audioRequested*/ ctx[4]) return create_if_block_7;
    		return create_else_block_2;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block1 = current_block_type(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (/*$videoRequested*/ ctx[3]) return create_if_block_4;
    		return create_else_block_1;
    	}

    	let current_block_type_1 = select_block_type_2(ctx);
    	let if_block2 = current_block_type_1(ctx);

    	function select_block_type_3(ctx, dirty) {
    		if (/*$audioRequested*/ ctx[4]) return create_if_block_3;
    		return create_else_block;
    	}

    	let current_block_type_2 = select_block_type_3(ctx);
    	let if_block3 = current_block_type_2(ctx);
    	let if_block4 = /*advancedSettingsSupported*/ ctx[10] && create_if_block_2(ctx);

    	continuebutton = new ContinueButton({
    			props: {
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			}
    		});

    	continuebutton.$on("click", /*handleDone*/ ctx[17]);
    	let if_block5 = /*advancedSettings*/ ctx[2] && create_if_block_1(ctx);

    	return {
    		c() {
    			div2 = element("div");
    			t0 = space();
    			create_component(video.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			if_block1.c();
    			t2 = space();
    			div0 = element("div");
    			button0 = element("button");
    			if_block2.c();
    			t3 = space();
    			button1 = element("button");
    			if_block3.c();
    			t4 = space();
    			if (if_block4) if_block4.c();
    			t5 = space();
    			create_component(continuebutton.$$.fragment);
    			t6 = space();
    			if (if_block5) if_block5.c();
    			if_block5_anchor = empty();
    			attr(button0, "class", "svelte-1puomlw");
    			toggle_class(button0, "track-disabled", !/*$videoRequested*/ ctx[3]);
    			set_style(button1, "--audio-level", (/*$audioLevelSpring*/ ctx[6] * 85 + 15).toFixed(2) + '%');
    			attr(button1, "class", "svelte-1puomlw");
    			toggle_class(button1, "audio-level", /*$audioRequested*/ ctx[4] && /*$audioLevelSpring*/ ctx[6] > AUDIO_LEVEL_MINIMUM);
    			toggle_class(button1, "track-disabled", !/*$audioRequested*/ ctx[4]);
    			attr(div0, "class", "button-tray svelte-1puomlw");
    			attr(div1, "class", "video-stack overlay svelte-1puomlw");
    			attr(div2, "class", "video-box svelte-1puomlw");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, t0);
    			mount_component(video, div2, null);
    			append(div2, t1);
    			append(div2, div1);
    			if_block1.m(div1, null);
    			append(div1, t2);
    			append(div1, div0);
    			append(div0, button0);
    			if_block2.m(button0, null);
    			append(div0, t3);
    			append(div0, button1);
    			if_block3.m(button1, null);
    			append(div0, t4);
    			if (if_block4) if_block4.m(div0, null);
    			insert(target, t5, anchor);
    			mount_component(continuebutton, target, anchor);
    			insert(target, t6, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert(target, if_block5_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(button0, "click", /*toggleVideoRequested*/ ctx[14]),
    					listen(button1, "click", /*toggleAudioRequested*/ ctx[13])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			const video_changes = {};
    			if (dirty & /*$localTracksStore*/ 32) video_changes.track = /*$localTracksStore*/ ctx[5].video;
    			video.$set(video_changes);

    			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div1, t2);
    				}
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type_1(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(button0, null);
    				}
    			}

    			if (dirty & /*$videoRequested*/ 8) {
    				toggle_class(button0, "track-disabled", !/*$videoRequested*/ ctx[3]);
    			}

    			if (current_block_type_2 === (current_block_type_2 = select_block_type_3(ctx)) && if_block3) {
    				if_block3.p(ctx, dirty);
    			} else {
    				if_block3.d(1);
    				if_block3 = current_block_type_2(ctx);

    				if (if_block3) {
    					if_block3.c();
    					if_block3.m(button1, null);
    				}
    			}

    			if (!current || dirty & /*$audioLevelSpring*/ 64) {
    				set_style(button1, "--audio-level", (/*$audioLevelSpring*/ ctx[6] * 85 + 15).toFixed(2) + '%');
    			}

    			if (dirty & /*$audioRequested, $audioLevelSpring, AUDIO_LEVEL_MINIMUM*/ 80) {
    				toggle_class(button1, "audio-level", /*$audioRequested*/ ctx[4] && /*$audioLevelSpring*/ ctx[6] > AUDIO_LEVEL_MINIMUM);
    			}

    			if (dirty & /*$audioRequested*/ 16) {
    				toggle_class(button1, "track-disabled", !/*$audioRequested*/ ctx[4]);
    			}

    			if (/*advancedSettingsSupported*/ ctx[10]) if_block4.p(ctx, dirty);
    			const continuebutton_changes = {};

    			if (dirty & /*$$scope*/ 16777216) {
    				continuebutton_changes.$$scope = { dirty, ctx };
    			}

    			continuebutton.$set(continuebutton_changes);

    			if (/*advancedSettings*/ ctx[2]) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty & /*advancedSettings*/ 4) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_1(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(video.$$.fragment, local);
    			transition_in(continuebutton.$$.fragment, local);
    			transition_in(if_block5);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block0);
    			transition_out(video.$$.fragment, local);
    			transition_out(continuebutton.$$.fragment, local);
    			transition_out(if_block5);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div2);
    			destroy_component(video);
    			if_block1.d();
    			if_block2.d();
    			if_block3.d();
    			if (if_block4) if_block4.d();
    			if (detaching) detach(t5);
    			destroy_component(continuebutton, detaching);
    			if (detaching) detach(t6);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach(if_block5_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    // (182:8) {:else}
    function create_else_block_5(ctx) {
    	let t;

    	return {
    		c() {
    			t = text("Cam and mic are not active");
    		},
    		m(target, anchor) {
    			insert(target, t, anchor);
    		},
    		p: noop,
    		d(detaching) {
    			if (detaching) detach(t);
    		}
    	};
    }

    // (179:8) {#if requestBlocked}
    function create_if_block_10(ctx) {
    	let t0;
    	let button;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			t0 = text("Cam and mic are blocked\n          ");
    			button = element("button");
    			button.textContent = "(Need help?)";
    			attr(button, "class", "svelte-1puomlw");
    		},
    		m(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, button, anchor);

    			if (!mounted) {
    				dispose = listen(button, "click", /*handleHelp*/ ctx[18]);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d(detaching) {
    			if (detaching) detach(t0);
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (192:35) {:else}
    function create_else_block_4(ctx) {
    	let t;

    	return {
    		c() {
    			t = text("Request Permissions");
    		},
    		m(target, anchor) {
    			insert(target, t, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(t);
    		}
    	};
    }

    // (192:6) {#if requestBlocked}
    function create_if_block_9(ctx) {
    	let t;

    	return {
    		c() {
    			t = text("Try Again");
    		},
    		m(target, anchor) {
    			insert(target, t, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(t);
    		}
    	};
    }

    // (191:4) <ContinueButton on:click={requestPermissions}>
    function create_default_slot_1(ctx) {
    	let if_block_anchor;

    	function select_block_type_5(ctx, dirty) {
    		if (/*requestBlocked*/ ctx[0]) return create_if_block_9;
    		return create_else_block_4;
    	}

    	let current_block_type = select_block_type_5(ctx);
    	let if_block = current_block_type(ctx);

    	return {
    		c() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},
    		p(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type_5(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (122:8) {:else}
    function create_else_block_2(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (120:35) 
    function create_if_block_7(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			div.textContent = "Join with mic off";
    			attr(div, "class", "message svelte-1puomlw");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (118:35) 
    function create_if_block_6(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			div.textContent = "Join with cam off";
    			attr(div, "class", "message svelte-1puomlw");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (116:8) {#if !$audioRequested && !$videoRequested}
    function create_if_block_5(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			div.textContent = "Join with cam and mic off";
    			attr(div, "class", "message svelte-1puomlw");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (132:12) {:else}
    function create_else_block_1(ctx) {
    	let img;
    	let img_src_value;

    	return {
    		c() {
    			img = element("img");
    			if (img.src !== (img_src_value = img$3)) attr(img, "src", img_src_value);
    			attr(img, "width", "32");
    			attr(img, "alt", "Video Disabled");
    			attr(img, "class", "svelte-1puomlw");
    		},
    		m(target, anchor) {
    			insert(target, img, anchor);
    		},
    		p: noop,
    		d(detaching) {
    			if (detaching) detach(img);
    		}
    	};
    }

    // (130:12) {#if $videoRequested}
    function create_if_block_4(ctx) {
    	let img;
    	let img_src_value;

    	return {
    		c() {
    			img = element("img");
    			if (img.src !== (img_src_value = img$4)) attr(img, "src", img_src_value);
    			attr(img, "width", "32");
    			attr(img, "alt", "Video Enabled");
    			attr(img, "class", "svelte-1puomlw");
    		},
    		m(target, anchor) {
    			insert(target, img, anchor);
    		},
    		p: noop,
    		d(detaching) {
    			if (detaching) detach(img);
    		}
    	};
    }

    // (146:12) {:else}
    function create_else_block(ctx) {
    	let img;
    	let img_src_value;

    	return {
    		c() {
    			img = element("img");
    			if (img.src !== (img_src_value = img$1)) attr(img, "src", img_src_value);
    			attr(img, "width", "32");
    			attr(img, "alt", "Audio Disabled");
    			attr(img, "class", "svelte-1puomlw");
    		},
    		m(target, anchor) {
    			insert(target, img, anchor);
    		},
    		p: noop,
    		d(detaching) {
    			if (detaching) detach(img);
    		}
    	};
    }

    // (144:12) {#if $audioRequested}
    function create_if_block_3(ctx) {
    	let img;
    	let img_src_value;

    	return {
    		c() {
    			img = element("img");
    			if (img.src !== (img_src_value = img$2)) attr(img, "src", img_src_value);
    			attr(img, "width", "32");
    			attr(img, "alt", "Audio Enabled");
    			attr(img, "class", "svelte-1puomlw");
    		},
    		m(target, anchor) {
    			insert(target, img, anchor);
    		},
    		p: noop,
    		d(detaching) {
    			if (detaching) detach(img);
    		}
    	};
    }

    // (150:10) {#if advancedSettingsSupported}
    function create_if_block_2(ctx) {
    	let button;
    	let img$1;
    	let img_src_value;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			img$1 = element("img");
    			if (img$1.src !== (img_src_value = img)) attr(img$1, "src", img_src_value);
    			attr(img$1, "width", "32");
    			attr(img$1, "alt", "Settings");
    			attr(img$1, "class", "svelte-1puomlw");
    			attr(button, "class", "corner svelte-1puomlw");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			append(button, img$1);

    			if (!mounted) {
    				dispose = listen(button, "click", /*toggleAdvancedSettings*/ ctx[15]);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (158:4) <ContinueButton on:click={handleDone}>
    function create_default_slot(ctx) {
    	let t;

    	return {
    		c() {
    			t = text("Continue");
    		},
    		m(target, anchor) {
    			insert(target, t, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(t);
    		}
    	};
    }

    // (159:4) {#if advancedSettings}
    function create_if_block_1(ctx) {
    	let div;
    	let deviceselector;
    	let current;
    	deviceselector = new DeviceSelector({ props: { selected: selectedDevices } });
    	deviceselector.$on("changed", /*changed_handler*/ ctx[20]);

    	return {
    		c() {
    			div = element("div");
    			create_component(deviceselector.$$.fragment);
    			attr(div, "class", "advanced-settings");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(deviceselector, div, null);
    			current = true;
    		},
    		p: noop,
    		i(local) {
    			if (current) return;
    			transition_in(deviceselector.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(deviceselector.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			destroy_component(deviceselector);
    		}
    	};
    }

    function create_fragment(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block_3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*hasPermission*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c() {
    			div = element("div");
    			if_block.c();
    			attr(div, "class", "mirror svelte-1puomlw");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};
    }

    const AUDIO_LEVEL_MINIMUM = 0.0;
    let letMeHearMyself = false;

    function instance($$self, $$props, $$invalidate) {
    	let $localAudioLevel;
    	let $videoRequested;
    	let $audioRequested;
    	let $localTracksStore;
    	let $audioLevelSpring;
    	let $videoPositionSpring;
    	component_subscribe($$self, localAudioLevel, $$value => $$invalidate(19, $localAudioLevel = $$value));
    	component_subscribe($$self, localTracksStore, $$value => $$invalidate(5, $localTracksStore = $$value));
    	const dispatch = createEventDispatcher();
    	const audioRequested = requestedTracks.audio;
    	component_subscribe($$self, audioRequested, value => $$invalidate(4, $audioRequested = value));
    	const videoRequested = requestedTracks.video;
    	component_subscribe($$self, videoRequested, value => $$invalidate(3, $videoRequested = value));

    	// Local state
    	let requestBlocked = false;

    	let hasPermission = false;
    	let advancedSettings = false;
    	let advancedSettingsSupported = JitsiMeetJS.util.browser.isChrome();

    	// Animation springs
    	let audioLevelSpring = spring(0, { stiffness: 0.3, damping: 0.8 });

    	component_subscribe($$self, audioLevelSpring, value => $$invalidate(6, $audioLevelSpring = value));
    	let videoPositionSpring = spring(0, { stiffness: 0.5, damping: 0.3 });
    	component_subscribe($$self, videoPositionSpring, value => $$invalidate(7, $videoPositionSpring = value));

    	const shakeInactiveVideo = () => {
    		videoPositionSpring.set(10);
    		setTimeout(() => videoPositionSpring.set(0), 100);
    	};

    	const toggleAudioRequested = () => set_store_value(audioRequested, $audioRequested = !$audioRequested, $audioRequested);
    	const toggleVideoRequested = () => set_store_value(videoRequested, $videoRequested = !$videoRequested, $videoRequested);
    	const toggleAdvancedSettings = () => $$invalidate(2, advancedSettings = !advancedSettings);

    	function setRequestBlocked(blocked) {
    		if (blocked) {
    			if (requestBlocked) {
    				// Visual feedback already indicates red,
    				// so shake it to emphasize error
    				shakeInactiveVideo();
    			}

    			$$invalidate(0, requestBlocked = true);
    		} else {
    			$$invalidate(0, requestBlocked = false);
    		}
    	}

    	/**
     * localTracks, audioRequested, videoRequested
     * @returns hasPermission, blocked(?), tracks
     */
    	async function requestPermissions() {
    		$$invalidate(1, hasPermission = await localTracksStore.request());

    		// Visually indicate that the request was blocked if we don't have permission
    		setRequestBlocked(!hasPermission);

    		// After asking for permission, it's possible the browser will now allow us
    		// to see more information about the devices available to the user, so requery
    		await deviceList.requery();
    	}

    	const handleDone = () => {
    		dispatch("done");
    	};

    	const handleHelp = () => {
    		alert("TODO");
    	};

    	onMount(async () => {
    		const autoPermit = await canAutoPermit();

    		if (autoPermit) {
    			requestPermissions();
    		}
    	});

    	const changed_handler = _ => {
    		requestPermissions();
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$localAudioLevel*/ 524288) {
    			// const audioLevelChanged = (level) => audioLevelSpring.set(level)
    			audioLevelSpring.set($localAudioLevel);
    		}
    	};

    	return [
    		requestBlocked,
    		hasPermission,
    		advancedSettings,
    		$videoRequested,
    		$audioRequested,
    		$localTracksStore,
    		$audioLevelSpring,
    		$videoPositionSpring,
    		audioRequested,
    		videoRequested,
    		advancedSettingsSupported,
    		audioLevelSpring,
    		videoPositionSpring,
    		toggleAudioRequested,
    		toggleVideoRequested,
    		toggleAdvancedSettings,
    		requestPermissions,
    		handleDone,
    		handleHelp,
    		$localAudioLevel,
    		changed_handler
    	];
    }

    class Mirror extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance, create_fragment, safe_not_equal, {});
    	}
    }

    /**
     * Restrict valid function names to 'addEventListener' and 'removeEventListener'
     *
     * @param {string} direction - 'add' | 'remove'
     */
    function eventListenerDirection(direction) {
      switch (direction) {
        case 'add':
          return 'addEventListener'
        case 'remove':
          return 'removeEventListener'
        default:
          throw new Error(
            `eventListener direction must be 'add' or 'remove', but was '${direction}'`
          )
      }
    }

    function trackDirection(direction) {
      switch (direction) {
        case 'add':
          return 'addTrack'
        case 'remove':
          return 'removeTrack'
        default:
          throw new Error(
            `addRemoveTrack direction must be 'add' or 'remove', but was '${direction}'`
          )
      }
    }

    /**
     * Add or remove a batch of JitsiMeetJS events on a given listening object
     *
     * @param {string} direction - 'add' | 'remove' event listeners
     * @param {any} listening - object that can listen for events, i.e. must have 'addEventListener', 'removeEventListener'
     * @param {object} events - an object containing event types as keys and values as object containing event names as keys and event functions as values
     */
    function wireEventListeners(direction, listening, events) {
      let fnName = eventListenerDirection(direction);

      for (const eventType of Object.keys(events)) {
        for (const [eventName, callback] of Object.entries(events[eventType])) {
          listening[fnName](JitsiMeetJS.events[eventType][eventName], callback);
        }
      }
    }

    function createSingleParticipantStore(isLocal = false) {
      // Stores participant properties
      const fieldsStore = writable({
        jid: null,
        role: null,

        audioEnabled: false,
        videoEnabled: false,
        desktopEnabled: false,

        // boolean
        isLocal: isLocal,
      });

      // Stores JitsiTrack by track type ('audio' | 'video')
      const tracksStore = writable({});

      // Store audioLevel separately because it changes frequently (~40ms)
      const audioLevelStore = writable(0.0);

      // The main participant store, derived from other stores
      const store = derived(
        [fieldsStore, tracksStore, audioLevelStore],
        ([$fields, $tracks, $audioLevel], set) => {
          set({
            ...$fields,
            ...$tracks,
            audioLevel: $audioLevel,
          });
        },
        {}
      );

      const events = {
        audio: {
          track: {
            TRACK_AUDIO_LEVEL_CHANGED: (audioLevel) => {
              audioLevelStore.set(audioLevel);
            },
            TRACK_MUTE_CHANGED: (track) => {
              fieldsStore.update(($fields) => ({
                ...$fields,
                audioEnabled: !track.isMuted(),
              }));
            },
          },
        },
        video: {
          track: {
            TRACK_MUTE_CHANGED: (track) => {
              fieldsStore.update(($fields) => ({
                ...$fields,
                videoEnabled: !track.isMuted(),
              }));
            },
          },
        },
      };

      return {
        subscribe: store.subscribe,

        setJid: (jid) => {
          fieldsStore.update(($fields) => ({ ...$fields, jid }));
        },

        setRole: (role) => {
          fieldsStore.update(($fields) => ({ ...$fields, role }));
        },

        setAudioEnabled: (enabled) => {
          const tracks = get_store_value(tracksStore);
          if (tracks.audio) {
            if (enabled) {
              tracks.audio.unmute();
            } else {
              tracks.audio.mute();
            }
          }
        },

        setVideoEnabled: (enabled) => {
          const tracks = get_store_value(tracksStore);
          if (tracks.video) {
            if (enabled) {
              tracks.video.unmute();
            } else {
              tracks.video.mute();
            }
          }
        },

        setAudioLevel: (audioLevel) => {
          audioLevelStore.set(audioLevel);
        },

        updateFieldsFromJitsiParticipant: (participant) => {
          fieldsStore.update(($fields) => {
            return {
              ...$fields,
              jid: participant.getId(),
              role: participant.getRole(),
            };
          });
        },

        addTrack: (track) => {
          if (track) {
            const trackType = track.getType();
            if (events[trackType]) {
              wireEventListeners("add", track, events[trackType]);
            }
            fieldsStore.update(($fields) => ({
              ...$fields,
              [`${trackType}Enabled`]: !track.isMuted(),
            }));
            tracksStore.update(($tracks) => ({
              ...$tracks,
              [trackType]: track,
            }));
          }
        },

        removeTrack: (track) => {
          if (track) {
            const trackType = track.getType();
            if (events[trackType]) {
              wireEventListeners("remove", track, events[trackType]);
            }
            tracksStore.update(($tracks) => omit($tracks, [trackType]));
          }
        },

        // Expose read-only versions of stores so they can be subscribed to individually
        fieldsStore: { subscribe: fieldsStore.subscribe },
        tracksStore: { subscribe: tracksStore.subscribe },
        audioLevelStore: { subscribe: audioLevelStore.subscribe },
      };
    }

    function createParticipantsStore() {
      const store = writable({});

      const { subscribe, update, set } = store;

      const updateParticipant = (participantId, action) => {
        let participant = get_store_value(store)[participantId];
        if (participant) {
          action(participant, false);
        } else {
          store.update(($participants) => {
            if ($participants[participantId]) {
              console.warn(`participant '${participantId}' should not exist`);
            }
            participant = createSingleParticipantStore();
            action(participant, true);
            return {
              ...$participants,
              [participantId]: participant,
            };
          });
        }
      };

      return {
        subscribe,
        update,
        updateParticipant,
        set,
      };
    }

    /**
     * Attach a set of local tracks to a conference.
     *
     * @param {JitsiConference} conference - Conference instance.
     * @param {JitsiLocalTrack[]} localTracks - List of local media tracks.
     * @protected
     * @returns {Promise}
     */
    function addLocalTracksToConference(conference, localTracks) {
      const conferenceLocalTracks = conference.getLocalTracks();
      const promises = [];

      for (const track of localTracks) {
        // XXX The library lib-jitsi-meet may be draconian, for example, when
        // adding one and the same video track multiple times.
        if (conferenceLocalTracks.indexOf(track) === -1) {
          promises.push(
            conference.addTrack(track).catch((err) => {
              console.warn('Failed to add local track to conference', err);
            })
          );
        }
      }

      return Promise.all(promises)
    }

    const CLEANUP_EVENT_LISTENERS_MAX_TIMEOUT$1 = 4000;

    const ConferenceState = {
      INITIAL: "initial",
      JOINING: "joining",
      JOINED: "joined",
      LEAVING: "leaving",
      LEFT: "left",
      FAILED: "failed",
      ERROR: "error",
      KICKED: "kicked",
    };

    function createSingleConferenceStore(conferenceId, connectionStore) {
      const stateStore = writable(ConferenceState.INITIAL);

      // Boolean flag that signals the user has given permission to enter the conference
      const permitEntryStore = writable(false);

      // Each conference gets a "localParticipantStore" which is what represents
      // the user & the user's local tracks in this particular conference (player
      // can potentially be connected to multiple rooms at once).
      const localParticipantStore = createSingleParticipantStore(true);

      // A store of objects, keys are participantIds and values are stores
      const remoteParticipantsStore = createParticipantsStore();

      let localParticipantId;
      localParticipantStore.subscribe(
        ($localParticipant) => (localParticipantId = $localParticipant.jid)
      );

      const cachedTrackParticipantId = new WeakMap();

      const store = derived(
        connectionStore,
        ($connection, set) => {
          if ($connection) {
            const conference = $connection.initJitsiConference(conferenceId, {
              // per latest recommendation:
              // https://community.jitsi.org/t/sctp-channels-deprecation-use-websockets/79408/8
              openBridgeChannel: "websocket",
            });

            const setStatus = (state) => {
              switch (state) {
                case ConferenceState.JOINING:
                  // Record the ID we're given to identify "self"
                  localParticipantStore.setJid(conference.myUserId());
                  break;
                case ConferenceState.JOINED:
                  set(conference);
                  break;
                default:
                  set(null);
              }
              stateStore.set(state);
            };

            const addRemoveTrack = (track, direction) => {
              let fnName = trackDirection(direction);

              let pId = track.getParticipantId();
              if (!pId) {
                pId = cachedTrackParticipantId.get(track);
              }
              if (pId) {
                cachedTrackParticipantId.set(track, pId);
                remoteParticipantsStore.updateParticipant(pId, (pStore) => {
                  pStore[fnName](track);
                });
              } else {
                console.warn(`Track does not have participantId`, track);
              }
            };

            const events = {
              conference: {
                /**
                 * Events that affect the participant's status in the conference
                 */

                CONFERENCE_JOINED: () => setStatus(ConferenceState.JOINED),
                CONFERENCE_LEFT: () => {
                  wireEventListeners("remove", conference, events);
                  setStatus(ConferenceState.LEFT);
                },
                CONFERENCE_FAILED: () => setStatus(ConferenceState.FAILED),
                CONFERENCE_ERROR: (errorCode) => {
                  console.error("Jitsi conference error", errorCode);
                  setStatus(ConferenceState.ERROR);
                },
                KICKED: () => setStatus(ConferenceState.KICKED),

                /**
                 * Events that can be used to update participant's metadata
                 */

                USER_JOINED: (pId, participant) => {
                  remoteParticipantsStore.updateParticipant(pId, (pStore) => {
                    pStore.updateFieldsFromJitsiParticipant(participant);
                  });
                },
                USER_LEFT: (pId) => {
                  remoteParticipantsStore.update(($participants) => {
                    return omit($participants, [pId]);
                  });
                },
                USER_ROLE_CHANGED: (pId, role) => {
                  if (pId === localParticipantId) {
                    localParticipantStore.setRole(role);
                  } else {
                    remoteParticipantsStore.updateParticipant(pId, (pStore) => {
                      pStore.setRole(role);
                    });
                  }
                },

                /**
                 * "Track" events: we get notified whenever a remote participant adds an
                 * audio or video track to the conference, and we can then attach it to
                 * the local representation of the corresponding participant.
                 */

                TRACK_ADDED: (track) => {
                  addRemoveTrack(track, "add");
                },
                TRACK_REMOVED: (track) => {
                  addRemoveTrack(track, "remove");
                },
              },
            };

            // Add all `events` functions as eventListeners on the JitsiConference object
            wireEventListeners("add", conference, events);

            setStatus(ConferenceState.JOINING);
            conference.join();

            // When connection status changes, clean up before re-creating a new JitsiConference
            return () => {
              const $state = get_store_value(stateStore);
              if (
                $state === ConferenceState.JOINING ||
                $state === ConferenceState.JOINED
              ) {
                const $connection = get_store_value(connectionStore);

                // Can't leave if the connection is null
                if ($connection) {
                  // Leave the conference
                  setStatus(ConferenceState.LEAVING);
                  conference
                    .leave()
                    .then(() => {
                      console.log("Left conference", conferenceId);
                      // status will be set by CONFERENCE_LEFT callback
                    })
                    .catch((err) => {
                      setStatus(ConferenceState.LEFT);
                      console.warn("Error when leaving conference", err);
                    });

                  /**
                   * Make sure we clean up event listeners.
                   *
                   * NOTE: Hopefully this will have been taken care of by
                   *       the CONFERENCE_LEFT event, but if not this will
                   *       be our fallback, e.g. in the case of
                   *       CONFERENCE_FAILED or other states.
                   */
                  setTimeout(
                    () => wireEventListeners("remove", conference, events),
                    CLEANUP_EVENT_LISTENERS_MAX_TIMEOUT$1
                  );
                } else {
                  setStatus(ConferenceState.LEFT);
                  wireEventListeners("remove", conference, events);
                }
              } else {
                // Whether or not we're joined, we must still clean up event listeners
                setStatus(ConferenceState.LEFT);
                wireEventListeners("remove", conference, events);
              }
            };
          }
        },

        // Initial derived store value
        null
      );

      // Whenever the conference OR the localTrackStore changes, we want to re-add
      // local tracks to the conference.
      derived(
        [store, localTracksStore, permitEntryStore],
        ([$store, $localTracks, $permitEntry]) => {
          const conference = $store;
          const tracks = $localTracks;
          const permitEntry = $permitEntry;
          const r = { conference, tracks, permitEntry };
          return r;
        }
      ).subscribe(($props) => {
        if ($props.conference && $props.tracks && $props.permitEntry) {
          // Whenever local tracks exist, add them to the localParticipant for this conference
          // (Allows this participant to see self)
          localParticipantStore.addTrack($props.tracks.audio);
          localParticipantStore.addTrack($props.tracks.video);

          // When conference & local tracks exist, add local tracks to the conference
          // (Allows others to see this participant)
          const tracksList = Object.values($props.tracks);
          addLocalTracksToConference($props.conference, tracksList);
        }
      });

      /**
       * A store containing all participant stores, both local and remote.
       *
       * This derives from `store` because we need to guarantee that there is
       * at least one subscriber to `store`, so that the conference is joined.
       */
      const allParticipantsStore = derived(
        [
          localParticipantStore,
          remoteParticipantsStore,
          store /* ConferenceStore */,
        ],
        ([$localParticipant, $remoteParticipants, $store], set) => {
          if ($store) {
            const allParticipants = {};

            // Add remote participants
            for (let [participantId, remoteParticipantStore] of Object.entries(
              $remoteParticipants
            )) {
              if (get_store_value(remoteParticipantStore).jid) {
                allParticipants[participantId] = remoteParticipantStore;
              }
            }

            // Add local participant, if present
            if ($localParticipant && $localParticipant.jid) {
              allParticipants[$localParticipant.jid] = localParticipantStore;
            }

            set(allParticipants);
          } else {
            // If the ConferenceStore is null, then we consider the conference to have no participants
            set({});
          }
        },
        // Initial allParticipantsStore value
        {}
      );

      return {
        subscribe: store.subscribe,
        state: stateStore,
        localParticipant: localParticipantStore,
        participants: allParticipantsStore,
        permitEntry: (permit) => {
          permitEntryStore.set(permit);
        },
      };
    }

    function createConferencesStore(connectionStore) {
      const store = writable({});

      const { subscribe, update, set } = store;

      const join = (conferenceId) => {
        update(($store) => {
          return {
            ...$store,
            [conferenceId]: createSingleConferenceStore(
              conferenceId,
              connectionStore
            ),
          };
        });
      };

      const leave = (conferenceId) => {
        update(($store) => {
          $store[conferenceId];
          return omit($store, [conferenceId]);
        });
      };

      return { subscribe, join, leave };
    }

    // Global JitsiMeetJS Init
    //
    // Note: this needs to run just once, but it must run or there can be
    //   unusual errors, e.g.
    //   https://community.jitsi.org/t/why-is-rtcutils-missing-enumeratedevices/79005/3

    JitsiMeetJS.setLogLevel(JitsiMeetJS.logLevels.ERROR);

    JitsiMeetJS.init({
      audioLevelsInterval: 40,
      disableAudioLevels: false,
    });

    const ConnectState = {
      INITIAL: 'initial',
      CONNECTING: 'connecting',
      CONNECTED: 'connected',
      DISCONNECTING: 'disconnecting',
      DISCONNECTED: 'disconnected',
      FAILED: 'failed',
    };

    const CLEANUP_EVENT_LISTENERS_MAX_TIMEOUT = 4000;

    const DEFAULT_JITSI_CONFIG = {
      hosts: {
        domain: 'meet.jit.si',
        muc: 'conference.meet.jit.si',
        focus: 'focus.meet.jit.si',
      },
      externalConnectUrl: 'https://meet.jit.si/http-pre-bind',
      enableP2P: true,
      p2p: {
        enabled: true,
        preferH264: true,
        disableH264: true,
        useStunTurn: true,
      },
      useStunTurn: true,
      bosh: `https://meet.jit.si/http-bind`, // need to add `room=[ROOM]` when joining
      websocket: 'wss://meet.jit.si/xmpp-websocket',
      clientNode: 'http://jitsi.org/jitsimeet',
    };

    /**
     * Create a ConnectionStore that holds a single JitsiConnection instance when connected,
     * or `null` otherwise.
     *
     * If the config inside `configStore` is null, then disconnect.
     *
     * @param {ConfigStore} configStore
     */
    function createConnectionStore(config, room) {
      if (!config) {
        throw Error('Jitsi connection config required')
      }

      config.bosh += `?room=${room}`;

      const stateStore = writable(ConnectState.INITIAL);

      const qualityStore = writable(0.0);

      const store = writable();

      const connection = new JitsiMeetJS.JitsiConnection(null, null, config);

      const setStatus = (state) => {
        store.set(state === ConnectState.CONNECTED ? connection : null);
        stateStore.set(state);
      };

      const events = {
        connection: {
          CONNECTION_ESTABLISHED: () => setStatus(ConnectState.CONNECTED),
          CONNECTION_FAILED: () => setStatus(ConnectState.FAILED),
          CONNECTION_DISCONNECTED: () => {
            wireEventListeners('remove', connection, events);
            setStatus(ConnectState.DISCONNECTED);
          },
          WRONG_STATE: () => {
            console.error('Jitsi Connection: Wrong State');
            setStatus(ConnectState.FAILED);
          },
        },
        connectionQuality: {
          LOCAL_STATS_UPDATED: ({ connectionQuality }) => {
            // TODO: check that this is working when conference has been joined
            console.log('LOCAL_STATS_UPDATED', connectionQuality);
            qualityStore.set(connectionQuality);
          },
        },
      };

      wireEventListeners('add', connection, events);

      setStatus(ConnectState.CONNECTING);
      connection.connect();

      const disconnect = () => {
        // If connected, disconnect
        const $state = get_store_value(stateStore);
        if (
          $state === ConnectState.CONNECTING ||
          $state === ConnectState.CONNECTED
        ) {
          // Disconnect from the server
          setStatus(ConnectState.DISCONNECTING);
          connection.disconnect();

          /**
           * Make sure we clean up event listeners.
           *
           * NOTE: Hopefully this will have been taken care of by
           *       the CONNECTION_DISCONNECTED event, but if not
           *       this will be our fallback, e.g. in the case of
           *       CONNECTION_FAILED or other states.
           */
          setTimeout(
            () => wireEventListeners('remove', connection, events),
            CLEANUP_EVENT_LISTENERS_MAX_TIMEOUT
          );
        } else {
          // Whether or not we're connected, we must still clean up event listeners
          wireEventListeners('remove', connection, events);
        }
      };

      const conferencesStore = createConferencesStore(store);
      return {
        subscribe: store.subscribe,
        state: stateStore,
        quality: qualityStore,

        // Each connection can have multiple conferences (rooms)
        conferencesStore: conferencesStore,

        joinConference: (conferenceId) => conferencesStore.join(conferenceId),
        disconnect,
      }
    }

    exports.Audio = Audio;
    exports.DEFAULT_JITSI_CONFIG = DEFAULT_JITSI_CONFIG;
    exports.Mirror = Mirror;
    exports.Video = Video;
    exports.canAutoPermit = canAutoPermit;
    exports.createConnectionStore = createConnectionStore;
    exports.localTracksStore = localTracksStore;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({});
